% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_pseudotime.R
\name{plot_pseudotime}
\alias{plot_pseudotime}
\title{Plot pseudotime}
\usage{
plot_pseudotime(
  obj,
  p2d = HPOExplorer::load_phenotype_to_genes(1),
  disease_ids = p2d$disease_id[1:3],
  max_disease_ids = NULL,
  root_cells = NULL,
  map_root_cells = TRUE,
  id_col = NULL,
  learn_graph_control = list(prune_graph = FALSE, nn.cores =
    KGExplorer::set_cores()$workers),
  use_partition = TRUE,
  return_cds = FALSE,
  merge_trajectories = TRUE,
  symptom_color = "red",
  bg_colors = c("#5000ff", "white"),
  trajectory_graph_color = ggplot2::alpha("white", 0.8),
  title_col = NULL,
  title_width = 100,
  color_by_symptoms = TRUE,
  color_cells_by = if (color_by_symptoms) {
     "is_symptom"
 } else {
     "cluster"
 },
  point_alpha = 0.5,
  add_density = TRUE,
  density_filled = FALSE,
  density_adjust = 1,
  density_alpha = point_alpha,
  title = stringr::str_wrap(paste0(unique(disease_ids), collapse = "; "), 20 * 2.5),
  show_plot = TRUE,
  save_path = NULL,
  height = 8,
  width = 9,
  ...
)
}
\arguments{
\item{obj}{A \pkg{Seurat} object of trait data 
generated by \pkg{phenomix}
 (e.g. \link{prepare_hpo},  \link{prepare_opentargets}).}

\item{disease_ids}{One or more disease IDs found within \code{p2d}.}

\item{max_disease_ids}{Maximum number of \code{disease_ids} to include.
Set to \code{NULL} to include all.}

\item{root_cells}{NULL or a vector of starting cells. If provided,
pseudotime will start (i.e. be zero) at these cells. Both
\code{root_pr_nodes} and \code{root_cells} cannot be provided.}

\item{map_root_cells}{Attempt to map root cells onto equivalent IDs
across different ontologies.}

\item{learn_graph_control}{NULL or a list of control parameters to be
passed to the reversed graph embedding function. Default is NULL. A list
of potential control parameters is provided in details.}

\item{use_partition}{logical parameter that determines whether to use
partitions calculated during \code{cluster_cells} and therefore to learn
disjoint graph in each partition. When \code{use_partition = FALSE}, a
single graph is learned across all partitions. Default is TRUE.}

\item{return_cds}{Return the \code{CellDataSet} object.}

\item{save_path}{File name to save to.}

\item{...}{
  Arguments passed on to \code{\link[monocle3:plot_cells]{monocle3::plot_cells}}
  \describe{
    \item{\code{cds}}{cell_data_set for the experiment}
    \item{\code{x}}{the column of SingleCellExperiment::reducedDims(cds) to plot on the horizontal axis}
    \item{\code{y}}{the column of SingleCellExperiment::reducedDims(cds) to plot on the vertical axis}
    \item{\code{reduction_method}}{The lower dimensional space in which to plot cells.
Must be one of "UMAP", "tSNE", "PCA" and "LSI".}
    \item{\code{color_cells_by}}{What to use for coloring the cells. Must be either the
name of a column of colData(cds), or one of "clusters", "partitions", or
"pseudotime".}
    \item{\code{group_cells_by}}{How to group cells when labeling them. Must be either
the name of a column of colData(cds), or one of "clusters" or "partitions".
If a column in colData(cds), must be a categorical variable.}
    \item{\code{genes}}{Facet the plot, showing the expression of each gene in a facet
panel. Must be either a list of gene ids (or short names), or a dataframe
with two columns that groups the genes into modules that will be
aggregated prior to plotting. If the latter, the first column must be gene
ids, and the second must the group for each gene.}
    \item{\code{show_trajectory_graph}}{Whether to render the principal graph for the
trajectory. Requires that learn_graph() has been called on cds.}
    \item{\code{trajectory_graph_color}}{The color to be used for plotting the
trajectory graph.}
    \item{\code{trajectory_graph_segment_size}}{The size of the line segments used for
plotting the trajectory graph.}
    \item{\code{norm_method}}{How to normalize gene expression scores prior to plotting
them. Must be one of "log" or "size_only".}
    \item{\code{label_cell_groups}}{Whether to label cells in each group (as specified
by group_cells_by) according to the most frequently occurring label(s) (as
specified by color_cells_by) in the group. If false, plot_cells() simply
adds a traditional color legend.}
    \item{\code{label_groups_by_cluster}}{Instead of labeling each cluster of cells,
place each label once, at the centroid of all cells carrying that label.}
    \item{\code{group_label_size}}{Font size to be used for cell group labels.}
    \item{\code{labels_per_group}}{How many labels to plot for each group of cells.
Defaults to 1, which plots only the most frequent label per group.}
    \item{\code{label_branch_points}}{Whether to plot a label for each branch point in
the principal graph.}
    \item{\code{label_roots}}{Whether to plot a label for each root in the principal
graph.}
    \item{\code{label_leaves}}{Whether to plot a label for each leaf node in the
principal graph.}
    \item{\code{graph_label_size}}{How large to make the branch, root, and leaf labels.}
    \item{\code{cell_size}}{The size of the point for each cell}
    \item{\code{cell_stroke}}{The stroke used for plotting each cell - default is 1/2
of the cell_size}
    \item{\code{alpha}}{Alpha for the cells. Useful for reducing overplotting.}
    \item{\code{min_expr}}{Minimum expression threshold for plotting genes}
    \item{\code{rasterize}}{Whether to plot cells as a rastered bitmap. Requires the
ggrastr package.}
    \item{\code{scale_to_range}}{Logical indicating whether to scale expression to
percent of maximum expression.}
    \item{\code{label_principal_points}}{Logical indicating whether to label roots,
leaves, and branch points with principal point names. This is useful for
order_cells and choose_graph_segments in non-interactive mode.}
  }}
}
\description{
Plot trait in genomic latent space and
then compute pseudotime trajectories between a subset of 
Human Phenotype Ontology (HPO) phenotype that
are symptoms of a given disease (or set of diseases).
}
\examples{
obj <- get_HPO()
out <- plot_pseudotime(obj)
}
